{"version":3,"sources":["webpack://Vue/webpack/universalModuleDefinition","webpack://Vue/./compiler.js","webpack://Vue/./dep.js","webpack://Vue/./init.js","webpack://Vue/./node-ops.js","webpack://Vue/./observer.js","webpack://Vue/./render.js","webpack://Vue/./vdom.js","webpack://Vue/./vue.js","webpack://Vue/./watcher.js","webpack://Vue/webpack/bootstrap","webpack://Vue/webpack/runtime/define property getters","webpack://Vue/webpack/runtime/hasOwnProperty shorthand","webpack://Vue/webpack/runtime/make namespace object","webpack://Vue/webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;ACVA,WAAW,QAAQ;AACnB,WAAW,WAAW;;AAEf;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA,4CAA4C,qBAAqB;AACjE,4BAA4B,OAAO,OAAO,OAAO;AACjD,qCAAqC,aAAa;AAClD;AACA,kCAAkC,aAAa;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,iBAAiB,EAAE,iBAAiB,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,MAAM;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,KAAK,aAAa,IAAI,iBAAiB;AAC/D;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,eAAe;AACf;;AAEA;AACA,eAAe,8DAA8D;AAC7E;;AAEA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,sBAAsB,UAAU,KAAK,WAAW;AAChD;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,oBAAoB,EAAE,OAAO;AAC7B;AACA;AACA,iBAAiB,EAAE;AACnB,sBAAsB,GAAG,GAAG,qBAAqB;AACjD,kBAAkB;AAClB;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI,kBAAkB,MAAM,EAAE,cAAc,eAAe,MAAM;AAC5E;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/SA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7BoC;;AAE7B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH,EAAE,mDAAO;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCO;AACP;AACA;AACO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;AC7BuB;;AAEhB;AACP;AACA;AACA,mBAAmB,yCAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA,kBAAkB,yCAAG;AACrB;AACA;AACA;AACA;AACA;AACA,UAAU,gDAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;;;;;AClE+C;;AAExC;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAK;AACvB,KAAK;AACL;AACA,kBAAkB,0CAAK;AACvB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEO;AACP;AACA,cAAc,kDAAe;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/CqC;;AAEtB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,IAAI,mDAAoB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,oDAAqB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH,gBAAgB,qDAAsB;AACtC;;AAEA;AACA,IAAI,kDAAmB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAsB;AAC/C;AACA,KAAK;AACL;AACA,KAAK;AACL,MAAM,qDAAsB;AAC5B;AACA,GAAG;AACH,IAAI,qDAAsB;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM,mDAAoB;AAC1B;AACA;AACA,QAAQ,kDAAmB;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM,mDAAoB;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;;AAEA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iDAAkB;AACnC;AACA,IAAI,kDAAmB;AACvB;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACnK+B;AACgB;AACb;AACG;AACP;;AAE9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE,oDAAU;AACZ;AACA,EAAE,iDAAS;AACX;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,6DAAkB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,6CAAO,8BAA8B;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,4CAAK;AAClB,GAAG;AACH;AACA,aAAa,4CAAK;AAClB;;AAEA;AACA;;AAEA;AACA,iEAAe,GAAG;;;;;;;;;;;;;;;;;;;;ACvEgC;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI,gDAAU;AACd;AACA,IAAI,gDAAS;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,OAAO;;;;;;;UCtDtB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,sF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"vue.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue\"] = factory();\n\telse\n\t\troot[\"Vue\"] = factory();\n})(self, function() {\nreturn ","// import { parse } from './vue-srouce/src/compiler/parser'\n// import { generate } from './vue-srouce/src/compiler/codegen/index'\n\nexport function compileToFunctions(template) {\n  // 编译模板\n  console.log('compileToFunctions')\n\n  // 1. parse => ast\n  const ast = parse(template.trim())\n  console.log('ast', ast)\n  // 2. ast => generate => code\n  const code = generate(ast)\n\n  return new Function(code.render)\n}\n\nexport const unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z${unicodeRegExp.source}]*`\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`\nconst startTagOpen = new RegExp(`^<${qnameCapture}`) // 匹配开始标签 '<div'\nconst startTagClose = /^\\s*(\\/?)>/ // 匹配结束标签 ' >' ' />'\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`)\n\nfunction parse(html) {\n  const stack = []\n  let index = 0\n  let last\n  while (html) {\n    last = html\n    let textEnd = html.indexOf('<')\n    if (textEnd === 0) {\n      // 结束标签\n      // End tag:\n      const endTagMatch = html.match(endTag)\n      if (endTagMatch) {\n        advance(endTagMatch[0].length)\n        stack.pop()\n        currentParent = stack[stack.length - 1]\n        continue\n      }\n      // 开始标签\n      const startTagMatch = parseStartTag()\n      if (startTagMatch) {\n        handleStartTag(startTagMatch)\n        continue\n      }\n    }\n    let text, rest, next\n    if (textEnd >= 0) {\n      rest = html.slice(textEnd)\n      while (!endTag.test(rest) && !startTagOpen.test(rest)) {\n        // < in plain text, be forgiving and treat it as text\n        next = rest.indexOf('<', 1)\n        if (next < 0) break\n        textEnd += next\n        rest = html.slice(textEnd)\n      }\n      text = html.substring(0, textEnd) // 获得标签内容\n    }\n    if (textEnd < 0) {\n      text = html\n    }\n\n    if (text) {\n      advance(text.length)\n      if (currentParent && text.trim()) {\n        const res = parseText(text)\n        let child\n        if (res) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text,\n          }\n        } else {\n          child = {\n            type: 3,\n            text,\n          }\n        }\n        currentParent.children.push(child)\n      }\n    }\n\n    if (html === last) {\n      break\n    }\n  }\n\n  function advance(n) {\n    index += n\n    html = html.substring(n)\n  }\n\n  function parseStartTag() {\n    const start = html.match(startTagOpen)\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      }\n      advance(start[0].length)\n      let end, attr\n      while (\n        !(end = html.match(startTagClose)) &&\n        (attr = html.match(attribute))\n      ) {\n        advance(attr[0].length)\n        match.attrs.push(attr)\n      }\n      if (end) {\n        advance(end[0].length)\n        return match\n      }\n    }\n  }\n  function handleStartTag(match) {\n    const tagName = match.tagName\n\n    const l = match.attrs.length\n    const attrs = new Array(l)\n    for (let i = 0; i < l; i++) {\n      const args = match.attrs[i]\n      const value = args[3] || args[4] || args[5] || ''\n\n      attrs[i] = {\n        name: args[1],\n        value,\n      }\n    }\n\n    // createASTElement\n    let element = createASTElement(tagName, attrs, currentParent)\n    stack.push(element)\n    if (currentParent) {\n      currentParent.children.push(element)\n      currentParent = element\n    }\n\n    if (!root) {\n      root = currentParent = element\n    }\n\n    processAttrs(element)\n  }\n\n  return root\n}\n\nlet root // 用于最后返回整棵树\nlet currentParent // 用于构建ast树\n\nfunction createASTElement(tag, attrs, parent) {\n  return {\n    type: 1,\n    tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    parent,\n    children: [],\n  }\n}\n\nfunction makeAttrsMap(attrs) {\n  const map = new Map()\n  attrs.forEach(({ name, value }) => {\n    map.set(name, value)\n  })\n\n  return map\n}\nconst onRE = /^@|^v-on:/\nfunction processAttrs(el) {\n  let events\n  el.attrsList.forEach((attr) => {\n    let { name, value } = attr\n    // v-on\n    if (onRE.test(name)) {\n      name = name.replace(onRE, '')\n      if (!events) events = {}\n      events[name] = {\n        value,\n      }\n    }\n    //v-for\n    if (name === 'v-for') {\n      const [alias, forItems] = value.split(' in ')\n      el.alias = alias\n      el.for = forItems\n    }\n    if (name === ':key') {\n      el.key = value\n    }\n  })\n  if (events) {\n    el.events = events\n  }\n}\n\nconst tagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nfunction parseText(text) {\n  if (!tagRE.test(text)) {\n    return\n  }\n  const tokens = []\n  const rawTokens = []\n  let lastIndex = (tagRE.lastIndex = 0)\n  let match, index, tokenValue\n  while ((match = tagRE.exec(text))) {\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push((tokenValue = text.slice(lastIndex, index)))\n      tokens.push(JSON.stringify(tokenValue))\n    }\n    // tag token\n    const exp = match[1].trim()\n    tokens.push(`_s(${exp})`)\n    rawTokens.push({ '@binding': exp })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push((tokenValue = text.slice(lastIndex)))\n    tokens.push(JSON.stringify(tokenValue))\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens,\n  }\n}\nfunction generate(ast) {\n  const code = ast ? genElement(ast) : '_c(\"div\")'\n  console.log(code)\n  return {\n    render: `with(this){return ${code}}`,\n  }\n}\n\nfunction genElement(ast) {\n  if (ast.for && !ast.forProcessed) {\n    return genFor(ast)\n  }\n  return `_c('${ast.tag}', ${genData(ast)}, ${getChildren(ast)})`\n}\n\nfunction getChildren(ast) {\n  if (!ast) return ''\n\n  return `[${ast.children\n    .map((child) => {\n      if (child.type === 1) {\n        return genElement(child)\n      } else {\n        return genText(child)\n      }\n    })\n    .join(',')}]`\n}\n\nfunction genText(text) {\n  return `_v(${text.type === 2 ? text.expression : JSON.stringify(text.text)})`\n}\n\nfunction genData(ast) {\n  let data = '{'\n\n  const attrs = ast.attrsList\n    .filter((attr) => {\n      if (attr.name === ':key') return false\n      if (attr.name.startsWith('v-')) return false\n      if (ast.events && ast.attrsMap.has(attr.name)) {\n        return false\n      }\n      return true\n    })\n    .map((attr) => `${attr.name}: '${attr.value}'`)\n    .join(',')\n\n  if (ast.key) {\n    data += `key:${ast.key},`\n  }\n  if (attrs !== '') {\n    data += `attrs:{${attrs}},`\n  }\n  if (ast.events) {\n    data += `on:{${Object.keys(ast.events)\n      .map((ev) => `${ev}:${ast.events[ev].value}`)\n      .join(',')}}`\n  }\n  data += '}'\n  return data\n}\n\nfunction genFor(el) {\n  const exp = el.for\n  const alias = el.alias\n\n  el.forProcessed = true // 避免死循环\n  return (\n    `_l((${exp}),` + `function(${alias}){` + `return ${genElement(el)}` + '})'\n  )\n}\n","let uid = 0\nexport default class Dep {\n  constructor() {\n    this.id = uid++\n    this.subs = []\n  }\n  addSub(sub) {\n    this.subs.push(sub)\n  }\n  depend() {\n    Dep.target.addDep(this)\n  }\n  notify() {\n    this.subs.forEach((sub) => {\n      sub.update()\n    })\n  }\n}\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget(target) {\n  targetStack.push(target)\n  Dep.target = target\n}\n\nexport function popTarget() {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n","import { observe } from './observer'\n\nexport function initState(vm) {\n  const opts = vm.$options\n  if (opts.props) initProps(vm, opts.props)\n  if (opts.methods) initMethods(vm, opts.methods)\n  if (opts.data) initData(vm)\n  if (opts.computed) initComputed(vm, opts.computed)\n  if (opts.watch) initWatch(vm, opts.watch)\n}\n\nfunction initProps(vm, props) {}\nfunction initMethods(vm, methods) {\n  Object.keys(methods).forEach((key) => {\n    vm[key] = vm.$options.methods[key].bind(vm)\n  })\n}\nfunction initData(vm) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function' ? data() : data || {}\n\n  Object.keys(data).forEach((key) => {\n    proxy(vm, '_data', key)\n  })\n\n  observe(data)\n}\nfunction initComputed(vm, computeds) {}\nfunction initWatch(vm, watches) {}\n\nfunction proxy(target, sourceKey, key) {\n  Object.defineProperty(target, key, {\n    get() {\n      return target[sourceKey][key]\n    },\n    set(newVal) {\n      target[sourceKey][key] = newVal\n    },\n  })\n}\n","export function createElement(tagName) {\n  return document.createElement(tagName)\n}\nexport function createTextNode(data) {\n  return document.createTextNode(data)\n}\n\nexport function insertBefore(parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode)\n}\n\nexport function appendChild(node, child) {\n  node.appendChild(child)\n}\n\nexport function setTextContent(node, text) {\n  node.textContent = text\n}\n\nexport function parentNode(node) {\n  return node.parentNode\n}\n\nexport function removeChild(node, child) {\n  node.removeChild(child)\n}\n\nexport function nextSibling(node) {\n  return node.nextSibling\n}\n","import Dep from './dep'\n\nexport class Observor {\n  constructor(value) {\n    this.value = value\n    this.dep = new Dep()\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      // 1. 数组方法 响应式处理\n      // 2. 子项继续递归\n      value.forEach((item) => {\n        observe(item)\n      })\n    } else {\n      this.walk(value)\n    }\n  }\n  walk(value) {\n    Object.keys(value).forEach((key) => {\n      defineReactive(value, key)\n    })\n  }\n}\n\nexport function observe(value) {\n  if (!value || typeof value !== 'object') return\n  return new Observor(value)\n}\n\nfunction defineReactive(obj, key) {\n  const dep = new Dep()\n  let val = obj[key]\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    get() {\n      console.log('get', key, val)\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(val)) {\n            val.forEach((item) => {\n              observe(item)\n            })\n          }\n        }\n      }\n      return val\n    },\n    set(newVal) {\n      console.log('set', key, val, newVal)\n      if (newVal === val) return\n      val = newVal\n      childOb = observe(newVal)\n      dep.notify()\n    },\n  })\n}\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true,\n  })\n}\n","import VNode, { createTextVNode } from './vdom'\n\nexport function initRender(vm) {\n  installRenderHelpers(vm) // 源码在 renderMixin(Vue) 时安装\n\n  vm._c = (a, b, c, d) => createElement(vm, a, b, c)\n}\n\nfunction createElement(context, tag, data, children) {\n  let vnode\n  if (typeof tag === 'string') {\n    // children 数组打平\n    const childs = children.flat()\n    // 源码定义了 isReservedTag 在 src/platforms/web/util/element.js\n    if (['div,button,span'].includes(tag)) {\n      vnode = new VNode(tag, data, childs, undefined, context)\n    } else {\n      // unknown\n      vnode = new VNode(tag, data, childs, undefined, context)\n    }\n  } else {\n    // direct component options / constructor 创建组件\n    vnode = createComponent(tag, data, context, children)\n  }\n  return vnode\n}\n\nfunction createComponent(tag, data, context, children) {}\n\nexport function installRenderHelpers(target) {\n  target._s = toString\n  target._v = createTextVNode\n  target._l = renderList\n}\n\nfunction toString(val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) ||\n      Object.prototype.toString.call(val).slice(8, -1) === 'Object'\n    ? JSON.stringify(val, null, 2)\n    : String(val)\n}\n\nfunction renderList(val, render) {\n  const ret = val.map((item) => render(item))\n  return ret\n}\n","import * as nodeOps from './node-ops'\n\nexport default class VNode {\n  constructor(tag, data, children, text, context) {\n    this.tag = tag\n    this.data = data\n    this.children = children\n    this.text = text\n    this.context = context\n    this.key = data && data.key\n  }\n}\n\nexport function createTextVNode(val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\nexport function patch(oldVnode, vnode) {\n  console.log('patch', oldVnode, vnode)\n  if (oldVnode instanceof VNode) {\n    // TODO: diff\n    // vnode.elm = createElm(vnode)\n\n    // document.body.replaceChild(vnode.elm, oldVnode.elm)\n\n    patchVnode(oldVnode, vnode)\n  } else {\n    // 首次挂载\n    vnode.elm = createElm(vnode, document.body)\n\n    nodeOps.insertBefore(document.body, vnode.elm, oldVnode)\n    document.body.removeChild(oldVnode)\n  }\n}\n\nfunction createElm(vnode, parentElm) {\n  // console.log(vnode.tag)\n  if (vnode.tag) {\n    vnode.elm = nodeOps.createElement(vnode.tag)\n\n    vnode.children.forEach((vn) => {\n      const chElm = createElm(vn, vnode.elm)\n      if (vn.data && vn.data.on) {\n        Object.keys(vn.data.on).forEach((event) => {\n          console.log('listener')\n          chElm.addEventListener(event, () => {\n            console.log('click')\n            vn.data.on[event]()\n          })\n        })\n      }\n    })\n  } else {\n    vnode.elm = nodeOps.createTextNode(vnode.text)\n  }\n\n  if (parentElm) {\n    nodeOps.appendChild(parentElm, vnode.elm)\n  }\n  return vnode.elm\n}\n\nfunction patchVnode(oldVnode, vnode) {\n  const elm = (vnode.elm = oldVnode.elm) // 直接复用dom\n\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  if (!vnode.text) {\n    if (oldCh && ch && oldCh !== ch) updateChildren(elm, oldCh, ch)\n    else if (ch) {\n      if (oldVnode.text) nodeOps.setTextContent(elm, '')\n      addVnodes(elm, ch, 0, ch.length - 1)\n    } else if (oldCh) {\n      removeVnodes(oldCh, 0, oldCh.length - 1)\n    } else if (oldVnode.text) {\n      nodeOps.setTextContent(elm, '')\n    }\n  } else if (oldVnode.text !== vnode.text) {\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n}\n\n// diff算法\nfunction updateChildren(parentElm, oldCh, newCh) {\n  let oldStartIdx = 0\n  let newStartIdx = 0\n  let oldEndIdx = oldCh.length - 1\n  let newEndIdx = newCh.length - 1\n  let oldStartVnode = oldCh[0]\n  let newStartVnode = newCh[0]\n  let oldEndVnode = oldCh[oldEndIdx]\n  let newEndVnode = newCh[newEndIdx]\n\n  let refElm\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    // 这里oldVnode 不存在 是因为，之前的比对中根据key 找出来挪走了\n    if (!oldStartVnode) {\n      oldStartVnode = [++oldStartIdx]\n    } else if (!oldEndVnode) {\n      oldEndVnode = [--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode)\n      oldStartVnode = oldCh[++oldStartIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) {\n      // 老头 新尾\n      patchVnode(oldStartVnode, newEndVnode)\n      nodeOps.insertBefore(\n        parentElm,\n        oldStartVnode.elm,\n        nodeOps.nextSibling(oldEndVnode.elm)\n      )\n      oldStartVnode = oldCh[++oldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) {\n      patchVnode(oldEndVnode, newStartVnode)\n      nodeOps.insertBefore(parentElm, oldEndVnode.elm, newStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[++newStartIdx]\n    } else {\n      // TODO: 如果以上都没匹配到，就根据新的key 从老的节点里 把它找出来，然后挪到 newStartIdx 的位置，并清空\n      createElm(newStartVnode, parentElm)\n      newStartVnode = newCh[++newStartIdx]\n    }\n  }\n\n  if (oldStartIdx > oldEndIdx) {\n    refElm = !newCh[newEndIdx + 1] ? null : newCh[newEndIdx + 1].elm\n    addVnodes(parentElm, newCh, newStartIdx, newEndIdx)\n  } else if (newStartIdx > newEndIdx) {\n    removeVnodes(oldCh, oldStartIdx, oldEndIdx)\n  }\n}\n\nfunction addVnodes(parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    createElm(vnodes[startIdx], parentElm)\n  }\n}\n\nfunction removeVnodes(vnodes, startIdx, endIdx) {\n  for (; startIdx <= endIdx; ++startIdx) {\n    const ch = vnodes[startIdx]\n    if (ch) {\n      removeNode(ch.elm)\n    }\n  }\n}\n\nfunction removeNode(el) {\n  const parent = nodeOps.parentNode(el)\n  if (parent) {\n    nodeOps.removeChild(parent, el)\n  }\n}\n\nfunction sameVnode(a, b) {\n  return a.key === b.key && a.tag === b.tag\n}\n","import Watcher from './watcher'\nimport { compileToFunctions } from './compiler'\nimport { initState } from './init'\nimport { initRender } from './render'\nimport { patch } from './vdom'\n\nfunction Vue(options) {\n  this._watcher = null\n  this._watchers = []\n  this._init(options)\n}\n\nVue.prototype.$forceUpdate = function () {\n  const vm = this\n  if (vm._watcher) {\n    vm._watcher.update()\n  }\n}\n\nVue.prototype._init = function (options) {\n  this.$options = options\n  const vm = this\n  initRender(vm) // $slots, $scopedSlots, _c, $createElement, $attrs, $listeners\n  // callHook(vm, 'beforeCreate')\n  initState(vm)\n  // callHook(vm, 'created')\n  this.$mount(options.el)\n}\n\nVue.prototype.$mount = function (el) {\n  el = document.querySelector(el)\n  this.$options.render = compileToFunctions(el.outerHTML)\n  return this.mountComponent(this, el)\n}\n\nVue.prototype.mountComponent = function (vm, el) {\n  this.$el = el\n  // callHook(vm, 'beforeMount')\n  let updateComponent = function () {\n    vm._update(vm._render())\n  }\n  new Watcher(vm, updateComponent, noop, {}, true)\n\n  // Watcher的第二个参数如果是function 会被立即执行，所以立即_update 立即 patch，patch就是直接操作dom了\n  // callHook(vm, 'mounted')\n}\n\nVue.prototype._render = function () {\n  console.log('render: get vnode')\n  const vm = this\n  const vnode = vm.$options.render.call(vm, vm.$createElement)\n  return vnode\n}\n\nlet prevVnode\nVue.prototype._update = function (vnode) {\n  console.log('update: vnode => dom', vnode)\n  const vm = this\n\n  if (!prevVnode) {\n    // initial render\n    vm.$el = patch(vm.$el, vnode)\n  } else {\n    // updates\n    vm.$el = patch(prevVnode, vnode)\n  }\n\n  prevVnode = vnode\n}\n\nfunction noop() {}\nexport default Vue\n","import Dep, { pushTarget, popTarget } from './dep'\n\nlet uid = 0\nclass Watcher {\n  constructor(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm\n    this.cb = cb\n    this.id = ++uid\n    this.deps = []\n    this.depIds = new Set()\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = () => {\n        return vm[expOrFn]\n      }\n    }\n\n    this.value = this.get()\n  }\n\n  get() {\n    pushTarget(this)\n    let value = this.getter.call(this.vm, this.vm)\n    popTarget(this)\n    return value\n  }\n\n  addDep(dep) {\n    if (!this.depIds.has(dep.id)) {\n      dep.addSub(this)\n      this.depIds.add(dep.id)\n    }\n  }\n\n  update() {\n    this.run()\n  }\n  run() {\n    const value = this.get()\n    if (value !== this.value) {\n      const oldValue = this.value\n      this.value = value\n\n      this.cb.call(this.vm, value, oldValue)\n    }\n  }\n}\n\nexport default Watcher\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./vue.js\");\n"],"sourceRoot":""}